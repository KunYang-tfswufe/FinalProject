# 项目名称：基于边缘计算的藏红花全生长周期智能培育系统设计与实现

```
智能科技学院2026届本科毕业设计功能实现要求:

1.软硬件系统设计

可设计移动应用系统、基于智能硬件的应用系统、Web应用系统。

具体要求：

（1）能使用所学C/Java/Python等程序设计语言解决相对复杂的综合问题，目标集中，要有较为完整的主体业务逻辑（总体目标）；

（2）要采用合适的分层架构、视图和代码分离（总体架构）；

（3）要考虑系统所需要的用户界面适配显示效果（前端用户接口UI）；

（4）要使用MySQL/SQLServer/Oracle等数据库持久化的功能，其中移动应用系统、Web应用系统至少应包含6张业务逻辑关联数据表，并涉及到存储过程、触发器等技术点的应用（后端存储）；系统页面须实现响应式设计；整个系统须由前端页面和后台管理系统组成，后台管理系统能区分不同角色入口及对应管理权限；

（5）系统应该设计测试用例，通过测试，能反馈系统的稳定性和健壮性（系统测试），说明软/硬件系统核心功能是否达到预期；

（6）以微控制器（单片机51/STM32，推荐型号STM32L431RCT6，不建议使用型号STM32F103C8T6）为核心的智能应用系统，能够采用微控制器编写程序，实现传感器数据采集、设备终端数据显示、存储，系统应具有联网功能、数据通讯、网络控制、数据处理等功能，设备终端硬件需个人独立设计（底板可用面包板设计或PCB设计；各功能模块在底板集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型，设计应贴合具体应用场景，避免同质化套壳设计；

（7）以微处理器（ARM）为核心的智能应用系统，采用ARM处理器编写程序，实现传感器数据采集、设备终端数据显示及存储，系统具有联网功能、数据通讯、网络控制、数据处理等功能，设备终端硬件需个人独立设计（底板可用面包板设计或PCB设计；各功能模块在底板上集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型；

（8）智能物联网应用系统，针对特定的应用场景，采用物联网技术，将传感器、控制器、智能设备、互联网等多种物联网组件进行有机结合，实现对各种物品、设备、场所、人员的智能化管理和监控，要求选用合理的物联网中间件技术、系统运行安全稳定可靠，要求设备端硬件需个人独立设计（底板可用面包板设计，或PCB设计；各功能模块在底板上集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型。

适用专业：计算机科学与技术（1-7）、智能科学与技术（1-8）、物联网工程（1-8）、信息管理与信息系统（1-5）
知网地址:https://co2.cnki.net/Login.html?dp=tfswufe&r=1685087871577
账户为学号例如:42212346
密码例如:let*********3(星号为加密部分)
```

## 项目核心背景信息 (Project Core Context)

为了方便AI/LLM在后续对话中快速理解上下文，以下是截至当前时间点的项目核心背景信息摘要。

- **项目名称:** 基于边缘计算的藏红花全生长周期智能培育系统设计与实现
- **项目目标:** 设计并实现一个集数据采集、边缘处理、云端通信和跨平台应用控制于一体的完整物联网（IoT）智能农业解决方案。
- **核心架构 (四层模型):**
  1.  **感知控制层:** STM32微控制器负责实时采集环境数据（温湿度、光照、土壤湿度）并精确执行控制指令（水泵、补光灯等）。
  2.  **边缘计算层:** 树莓派作为边缘网关，负责与STM32进行串口通信，对数据进行本地存储、预处理和实时分析，并通过Flask提供局域网API服务。
  3.  **云服务层:** 采用MQTT协议，将边缘端处理后的关键数据上报至云端MQTT Broker，并订阅云端下发的控制指令，实现系统的远程监控。
  4.  **应用表现层:** 基于PWA（Progressive Web App）技术的前端应用，可自适应PC和移动设备，实现数据的可视化展现、远程设备控制和用户权限管理。

- **开发者及环境信息:**
  - **开发者操作系统:** **Arch Linux**
  - **嵌入式IDE:** **STM32CubeIDE**
  - **嵌入式调试工具:** **`minicom`** (串口通信测试)
  - **后端语言:** Python 3

- **硬件选型:**
  - **微控制器 (MCU):** `STM32L476RGT6U` (原型开发板: **NUCLEO-L476RG**)
  - **边缘计算设备:** **树莓派4B (Raspberry Pi 4B)**
  - **STM32 <-> 树莓派通信:** **UART串口**

---

## ✅ 项目规划清单 (Project Planning Checklist)

1.  **一句话项目描述:** `这个项目是做什么的？`
    > 答：一个集STM32数据采集、树莓派边缘处理、MQTT云通信和PWA跨平台控制于一体的藏红花智能培育物联网系统。
2.  **目标用户画像:** `我在为谁开发？`
    > 答：小王，一名对现代农业技术充满热情的智能农业专业学生或研究员。他希望通过自动化技术提高藏红花的种植效率和品质，并能随时随地通过手机或电脑（无论在本地还是外网）监控和管理培育环境。
3.  **MVP 功能列表:** `必须实现的核心功能有哪些？`
    > 1.  STM32能采集多路环境数据并上报给树莓派。
    > 2.  树莓派能接收数据、存入本地数据库，并通过API提供给前端。
    > 3.  PWA前端能实时展示来自API的环境数据。
    > 4.  用户能在PWA前端下发控制指令。
    > 5.  STM32能接收并执行树莓派转发来的控制指令。
    > 6.  树莓派能将数据推送到云端MQTT服务器。
4.  **技术栈清单:**
    > - **感知控制层 (STM32):** C语言, STM32 HAL库
    > - **边缘计算层 (树莓派):** Python, Flask, SQLAlchemy, Gunicorn, Paho-MQTT
    > - **云服务层:** 公共/自建 MQTT Broker (如 EMQX, Mosquitto)
    > - **应用表现层 (PWA):** Vue 3 (或 React), ECharts, Element Plus (或 Ant Design)
    > - **数据库:** MySQL (或 MariaDB)
    > - **开发/部署环境:** Arch Linux (开发), Raspberry Pi OS (部署), Nginx
5.  **高层架构图:**
    > ```
    > [ 感知控制层 ]          [ 边缘计算层 ]             [ 云服务层 ]             [ 应用表现层 ]
    > +-------------+        +----------------------+   +--------------+         +--------------+
    > | STM32       | UART   | Raspberry Pi         |   | MQTT Broker  |         | PWA          |
    > | + 传感器   | <------> | + Python Serial      |   |              |         | (PC/Mobile)  |
    > | + 执行器   |        | + Flask API (Local)  |---| (Internet) |---------|              |
    > +-------------+        | + MariaDB            |   |              |         +--------------+
    >                        | + MQTT Client        |---/              |
    >                        +----------------------+
    > ```
6.  **核心数据模型/表结构:** `项目的数据骨架，满足6张表要求。`
    > 答：详见下文 **“核心数据模型 (数据库设计)”** 章节。
7.  **主要页面线框图:**
    > - **登录页:** 用户名、密码输入。
    > - **数据仪表盘 (Dashboard):** 实时数据显示卡片、设备状态、ECharts实时曲线图、快捷控制开关。
    > - **历史数据页:** 按日期/时间范围查询历史数据，并以图表和表格形式展示。
    > - **后台管理页 (Admin):** 用户管理、角色权限分配、设备管理。
8.  **任务列表/看板:**
    > 答：见下文的 **“敏捷开发冲刺计划”**，已分解为四周的冲刺任务。
9.  **一个优秀的 README.md 草稿:**
    > 答：本文档本身即为项目 README 的持续演进版本。

---

## 核心数据模型 (数据库设计)

为满足毕业设计要求，系统设计以下6张核心数据表，均采用MySQL/MariaDB存储。

1.  **用户表 (users)**
    - `id` (INT, PK, AI): 用户ID
    - `username` (VARCHAR, UNIQUE): 用户名
    - `password_hash` (VARCHAR): 加密后的密码
    - `email` (VARCHAR, UNIQUE): 电子邮箱
    - `created_at` (DATETIME): 创建时间

2.  **角色表 (roles)**
    - `id` (INT, PK, AI): 角色ID
    - `role_name` (VARCHAR, UNIQUE): 角色名称 (如 'admin', 'observer')

3.  **用户角色关联表 (user_roles)**
    - `user_id` (INT, FK -> users.id): 用户ID
    - `role_id` (INT, FK -> roles.id): 角色ID

4.  **设备表 (devices)**
    - `id` (INT, PK, AI): 设备ID
    - `device_name` (VARCHAR): 设备名称 (如 '一号培育箱')
    - `location` (VARCHAR): 物理位置
    - `status` (VARCHAR): 设备状态 ('online', 'offline')
    - `last_seen` (DATETIME): 最后在线时间

5.  **传感器数据表 (sensor_data)**
    - `id` (BIGINT, PK, AI): 数据记录ID
    - `device_id` (INT, FK -> devices.id): 所属设备ID
    - `timestamp` (DATETIME, INDEX): 采集时间戳
    - `temperature` (FLOAT): 温度 (°C)
    - `humidity` (FLOAT): 湿度 (%)
    - `light_intensity` (FLOAT): 光照强度 (lux)
    - `soil_moisture` (FLOAT): 土壤湿度 (%)

6.  **控制日志表 (control_logs)**
    - `id` (BIGINT, PK, AI): 日志ID
    - `user_id` (INT, FK -> users.id): 操作用户ID
    - `device_id` (INT, FK -> devices.id): 被控设备ID
    - `actuator` (VARCHAR): 被控执行器 (如 'water_pump', 'led_light')
    - `action` (VARCHAR): 执行动作 (如 'ON', 'OFF')
    - `timestamp` (DATETIME): 操作时间
    - `result` (VARCHAR): 执行结果 ('success', 'failed')

---

## 🚀 敏捷开发冲刺计划 (Agile Development Sprint Plan) - 精细化任务分解

鉴于项目周期，我们采用以**周**为单位的冲刺（Sprint）模式。每个任务都被分解为具体、可执行的子任务。

---

### **第一周：核心链路贯通 (The "Tracer Bullet" Sprint)**

**🎯 本周目标：** 跑通一个最简化的 **传感器 -> STM32 -> 树莓派 -> 浏览器** 的端到端**局域网**数据流。这是项目的“龙骨”，验证技术栈的可行性。

- #### **任务 1.1: STM32 环境搭建与传感器读取**
  - [ ] **环境搭建:** 在 Arch Linux 上安装 STM32CubeIDE。
  - [ ] **项目创建:** 在 CubeIDE 中为 NUCLEO-L476RG 创建新项目。
  - [ ] **CubeMX 配置 (时钟与调试):** 配置 RCC (使用 HSI/HSE) 和 SYS (启用 SWD 调试)。
  - [ ] **CubeMX 配置 (UART):** 启用一个 USART 实例 (如 USART2)，配置引脚、波特率 (e.g., 115200)。
  - [ ] **CubeMX 配置 (传感器):** 为 DHT22 温湿度传感器配置一个 GPIO 引脚为输入/输出模式。
  - [ ] **代码生成:** 从 CubeMX 生成初始化代码。
  - [ ] **驱动编写:** 编写或移植 DHT22 驱动代码，实现读取温湿度值的函数。
  - [ ] **主循环逻辑:** 在 `main.c` 的 `while(1)` 循环中，定时调用传感器读取函数。
  - [ ] **[验证] 调试器验证:** 使用调试器 (Debugger) 设置断点，查看变量值，确认能读到非零的温湿度数据。

- #### **任务 1.2: STM32 数据格式化与串口发送**
  - [ ] **JSON 格式化:** 在主循环中，使用 `sprintf` 将读取到的温湿度值格式化为 JSON 字符串 (e.g., `{"temp":25.5,"humi":60.1}\r\n`)。 **注意：** 必须包含换行符 `\r\n` 作为消息结束符。
  - [ ] **UART 发送:** 调用 `HAL_UART_Transmit()` 函数将格式化后的字符串通过串口发送出去。
  - [ ] **添加延迟:** 在循环中加入 `HAL_Delay()` 确保发送频率不会过高 (e.g., 每 2-5 秒一次)。
  - [ ] **[验证] Arch Linux 串口监听:** 使用 `minicom -D /dev/ttyACM0 -b 115200` (或类似命令) 确认能持续收到正确的 JSON 数据流。

- #### **任务 1.3: 树莓派 Python 串口接收**
  - [ ] **环境准备 (树莓派):** 安装 Python3, pip, 及 `pyserial` 库 (`pip install pyserial`)。
  - [ ] **编写独立脚本 (`serial_test.py`):** 编写一个简单的 Python 脚本，使用 `pyserial` 循环读取串口一行数据 (`readline()`)，并打印到控制台。
  - [ ] **[验证] 数据解析:** 运行脚本，确认能正确接收并解析来自 STM32 的 JSON 字符串，无乱码或丢包。

- #### **任务 1.4: 最小化 Flask API 服务**
  - [ ] **环境准备 (树莓派):** 安装 `flask` (`pip install flask`)。
  - [ ] **创建 Flask 应用 (`app.py`):** 搭建一个最基础的 "Hello World" Flask 应用。
  - [ ] **数据暂存设计:** 设计一个简单的全局变量 (e.g., a dictionary `latest_data = {}`) 来存储最新的传感器读数。
  - [ ] **集成串口读取:** 将 `serial_test.py` 的逻辑封装成一个函数，并使用 `threading` 在 Flask 应用启动时在后台线程中运行此函数，持续更新 `latest_data`。
  - [ ] **创建 API 端点:** 编写 `GET /api/v1/sensors/latest` 路由，它返回 `latest_data` 的 JSON 格式。
  - [ ] **[验证] API 测试:** 在另一台电脑上使用 `curl http://<树莓派IP>:5000/api/v1/sensors/latest` 或浏览器访问，确认能获取 JSON 数据。

- #### **任务 1.5: 纯 JS 实时数据显示**
  - [ ] **创建 `index.html`:** 编写一个包含基本 HTML 结构的静态文件，内含用于显示数据的 `<div>` 或 `<span>` 元素 (e.g., `<p>Temperature: <span id="temp">--</span></p>`)。
  - [ ] **编写 JavaScript:** 在 `<script>` 标签内，使用 `setInterval` 和 `fetch` API，每隔几秒请求一次后端的 `/api/v1/sensors/latest` 接口。
  - [ ] **数据绑定:** 在 `fetch` 的回调函数中，解析返回的 JSON，并使用 `document.getElementById().innerText` 将数据更新到 HTML 页面上。
  - [ ] **本地服务:** 在树莓派上用 `python -m http.server 8000` 启动一个简单的 Web 服务器来提供 `index.html`。
  - [ ] **[验证] 端到端流程:** 在浏览器中打开 `http://<树莓派IP>:8000`，确认能看到来自 STM32 的数据在页面上实时刷新。

---

### **第二周：MVP 功能完善 (The MVP Feature Sprint)**

**🎯 本周目标：** 在核心链路基础上，扩展所有传感器，实现反向控制，并引入数据库进行数据持久化。

- #### **任务 2.1: STM32 功能扩展与反向控制**
  - [ ] **多传感器集成:** 编写光照强度、土壤湿度传感器的驱动代码，并将其数据加入到上报的 JSON 结构中。
  - [ ] **执行器控制:** 使用 CubeMX 配置一个 GPIO 为推挽输出模式，用于控制继电器（或 LED 作为替代）。
  - [ ] **控制函数编写:** 编写 `pump_on()` 和 `pump_off()` 函数来控制 GPIO 的高低电平。
  - [ ] **串口接收中断:** 配置 UART 接收中断，将收到的字符存入一个缓冲区。
  - [ ] **命令解析:** 在主循环中检查接收缓冲区，解析收到的 JSON 命令 (e.g., `{"actuator": "pump", "action": "on"}`)，并调用相应的控制函数。
  - [ ] **[验证] 串口调试助手:** 使用 PC 串口工具发送控制 JSON，观察 STM32 上的继电器/LED 是否动作。

- #### **任务 2.2: 后端数据库集成**
  - [ ] **数据库安装:** 在树莓派上安装 MariaDB/MySQL，并创建一个专用数据库和用户。
  - [ ] **Python 库安装:** 安装 `SQLAlchemy` 和 `PyMySQL` (`pip install flask-sqlalchemy pymysql`)。
  - [ ] **模型定义:** 在 Flask 应用中，使用 SQLAlchemy 定义 `Device` 和 `SensorData` 模型，对应数据库表结构。
  - [ ] **数据库初始化:** 编写一个命令或首次运行时自动创建所有数据表。
  - [ ] **数据持久化:** 修改串口接收的后台线程，在解析数据后，创建一个 `SensorData` 对象并存入数据库会话 (`db.session.add()`, `db.session.commit()`)。
  - [ ] **[验证] 数据库查询:** 使用数据库客户端 (如 `mysql` 命令行) 查询 `sensor_data` 表，确认新数据被持续写入。

- #### **任务 2.3: 后端控制 API 与日志**
  - [ ] **创建 `control_logs` 模型:** 在 Flask 中定义 `ControlLog` 模型。
  - [ ] **创建控制 API:** 创建 `POST /api/v1/control` 端点，接收形如 `{"actuator": "pump", "action": "on"}` 的 JSON body。
  - [ ] **指令转发:** API 内部逻辑将接收到的 JSON 格式化为与 STM32 约定的字符串，并通过 `pyserial` 写入串口。
  - [ ] **日志记录:** 每次调用控制 API 时，创建一个 `ControlLog` 记录并存入数据库。
  - [ ] **[验证] Postman/curl 测试:** 使用 Postman 或 curl 工具向该 API 发送 POST 请求，确认 STM32 端有响应，并且 `control_logs` 表中有新记录。

- #### **任务 2.4: 前端 Vue 仪表盘**
  - [ ] **项目初始化:** 使用 `npm create vue@latest` 创建 Vue3 项目，并安装 `axios` 和 UI 库 (如 `Element Plus`)。
  - [ ] **API 服务封装:** 创建一个 `api.js` 文件，将所有后端 API 请求封装成函数。
  - [ ] **仪表盘组件:** 创建一个 `Dashboard.vue` 组件，用于展示实时数据。
  - [ ] **实时数据获取:** 在 `Dashboard.vue` 的 `onMounted` 钩子中，使用 `setInterval` 定时调用获取最新数据的 API。
  - [ ] **控制按钮:** 在页面上添加开关或按钮，绑定 `@click` 事件，调用发送控制指令的 API。
  - [ ] **[验证] 端到端控制:** 在 Vue 页面上点击按钮，观察 STM32 上的物理设备是否动作。

---

### **第三周：云端通信与用户体验 (The Cloud & UX Sprint)**

**🎯 本周目标：** 引入用户认证系统、集成 MQTT 实现远程通信、完善数据可视化和响应式布局，使系统成为一个完整的应用。

- #### **任务 3.1: 后端用户认证 (RBAC)**
  - [ ] **数据库建表:** 使用 SQLAlchemy 定义 `User`, `Role`, `UserRole` 模型并生成数据表。
  - [ ] **库安装:** 安装 `Flask-Bcrypt` 用于密码加密，`Flask-JWT-Extended` 用于 Token 认证。
  - [ ] **创建注册/登录 API:** 实现 `POST /api/v1/auth/register` 和 `POST /api/v1/auth/login` 接口。登录成功返回 JWT。
  - [ ] **API 保护:** 使用 `@jwt_required()` 装饰器保护需要登录才能访问的 API (如控制 API)。
  - [ ] **角色权限:** 创建一个自定义装饰器 (e.g., `@admin_required`)，用于保护只有管理员能访问的 API。
  - [ ] **[验证] Postman 测试:** 测试注册、登录、携带 Token 访问受保护接口、无 Token 访问失败等场景。

- #### **任务 3.2: 后端与前端历史数据**
  - [ ] **创建历史 API:** 实现 `GET /api/v1/sensors/history`，支持 `start_time` 和 `end_time` 作为查询参数，从数据库分页查询数据。
  - [ ] **前端库安装:** 在 Vue 项目中安装 `ECharts` (`npm install echarts`)。
  - [ ] **历史数据页面:** 创建 `History.vue` 页面组件，包含日期范围选择器。
  - [ ] **数据可视化:** 当用户选择日期范围后，调用历史数据 API，并将返回的数据用 ECharts 渲染成折线图。
  - [ ] **[验证] 页面交互:** 在前端选择不同时间段，确认图表能正确刷新并展示对应的数据。

- #### **任务 3.3: MQTT 云端集成**
  - [ ] **选择 Broker:** 确定使用一个公共 MQTT Broker (如 EMQX Public MQTT Server) 进行开发。
  - [ ] **库安装:** 在树莓派上安装 `paho-mqtt` (`pip install paho-mqtt`)。
  - [ ] **MQTT 客户端封装:** 编写一个 `mqtt_client.py` 模块，处理连接、发布、订阅和回调逻辑。
  - [ ] **数据上报:** 在主程序的后台线程中，除了存数据库外，还将每条传感器数据 publish 到一个 Topic (e.g., `saffron/device1/data`)。
  - [ ] **指令下发:** 让 MQTT 客户端 subscribe 一个控制 Topic (e.g., `saffron/device1/control/set`)。在 `on_message` 回调中，解析收到的云端指令，并写入串口。
  - [ ] **[验证] MQTTX 测试:** 使用 MQTT 客户端工具 (如 MQTTX) 订阅数据 Topic，确认能收到树莓派发来的数据；再向控制 Topic 发布指令，确认 STM32 有响应。

- #### **任务 3.4: 前端完善与 PWA**
  - [ ] **用户流程:** 创建登录页面，实现完整的登录/登出逻辑，使用 `localStorage` 或 `Pinia` 存储 JWT。
  - [ ] **路由守卫:** 在 Vue Router 中设置导航守卫，未登录用户访问受保护页面时自动跳转到登录页。
  - [ ] **后台管理页:** 创建一个基础的后台管理页面 (路由受管理员角色保护)，用于展示用户列表。
  - [ ] **响应式设计:** 使用 CSS 媒体查询或 UI 库的栅格系统，确保仪表盘在手机和桌面端都能良好显示。
  - [ ] **PWA 配置:** 创建 `manifest.json` 并配置 `vite.config.js` (或 `vue.config.js`) 和 `Service Worker`，使应用可被“安装”到桌面或主屏幕。
  - [ ] **[验证] 多设备测试:** 在 PC 和手机浏览器中访问应用，检查布局和功能。尝试将应用添加到主屏幕。

- #### **任务 3.5: 数据库高级功能**
  - [ ] **设计存储过程:** 编写一个 SQL 存储过程，例如 `CleanOldSensorData(days_to_keep INT)`，用于定期删除指定天数之前的传感器数据。
  - [ ] **设计触发器:** 编写一个 SQL 触发器，例如当 `control_logs` 表中插入一条新记录时，自动更新 `devices` 表中对应设备的 `last_seen` 字段。
  - [ ] **[验证] 手动调用:** 在数据库客户端中手动调用存储过程和触发相关操作，检查数据是否按预期变化。

---

### **第四周：测试、部署与文档 (The Polish, Deploy & Document Sprint)**

**🎯 本周目标：** 确保系统稳定可靠，完成生产环境部署，并集中精力完成毕业设计文档的撰写。**原则上，本周不开发新功能。**

- #### **任务 4.1: 系统健壮性测试**
  - [ ] **编写测试用例:** 创建一个表格，列出核心功能的测试用例，包括正常场景和异常场景。
    - _示例1 (正常):_ 用户登录 -> 查看实时数据 -> 发送开灯指令 -> 确认灯亮 -> 登出。
    - _示例2 (异常):_ STM32 意外断电，前端应显示设备离线或数据不再更新。
    - _示例3 (异常):_ 树莓派断网，测试 MQTT 重连机制是否生效。
  - [ ] **执行测试:** 逐一执行测试用例，记录结果，对发现的 Bug 进行修复。
  - [ ] **压力测试 (可选):** 编写脚本快速向 API 发送请求，观察系统资源占用情况。

- #### **任务 4.2: 生产环境部署**
  - [ ] **安装部署软件:** 在树莓派上安装 `gunicorn` 和 `nginx`。
  - [ ] **配置 Gunicorn:** 使用 Gunicorn 启动 Flask 应用，取代开发用的 `flask run`。
  - [ ] **配置 Nginx:** 编写 Nginx 配置文件，设置反向代理，将 80 端口的请求转发给 Gunicorn 运行的端口。
  - [ ] **配置 systemd 服务:** 编写 `.service` 文件，将 Gunicorn 服务和 Python 串口监听脚本配置为开机自启动。
  - [ ] **前端打包与部署:** 运行 `npm run build` 打包 Vue 应用，将 `dist` 目录下的静态文件部署到 Nginx 的 Web 根目录。
  - [ ] **[验证] 重启测试:** 重启树莓派，稍等片刻后，直接通过 IP 访问，确认系统自动恢复并正常工作。

- #### **任务 4.3: 硬件定型**
  - [ ] **电路整理:** 将面包板上的电路整理清晰，确保连接稳固。
  - [ ] **焊接 (可选):** 如果时间充裕且条件允许，将电路焊接到洞洞板或设计的 PCB 上，制作一个简单的外壳。
  - [ ] **[验证] 最终硬件测试:** 确认定型后的硬件系统工作稳定。

- #### **任务 4.4: 文档与答辩准备**
  - [ ] **图表绘制:** 使用 draw.io 或类似工具绘制系统架构图、数据流图、数据库 E-R 图、核心 UML 用例图等。
  - [ ] **论文撰写:** 集中精力完成毕业论文的系统设计、实现、测试等关键章节的撰写。
  - [ ] **PPT 制作:** 准备答辩用的 PPT，内容应包括项目背景、需求分析、系统设计、核心功能演示、总结与展望。
  - [ ] **演示脚本:** 编写一份详细的现场演示流程脚本，确保演示流畅。

- #### **任务 4.5: 代码与项目收尾**
  - [ ] **代码审查与注释:** 通读所有代码，添加必要的注释，清理无用代码。
  - [ ] **README 完善:** 更新最终的 `README.md`，包含项目截图、技术栈详情、部署指南等。
  - [ ] **代码归档:** 将所有代码（STM32、Python 后端、Vue 前端）和文档整理归档，并提交到 Git 仓库。
