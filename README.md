# 项目名称：基于边缘计算的藏红花全生长周期智能培育系统设计与实现

```
智能科技学院2026届本科毕业设计功能实现要求:

1.软硬件系统设计

可设计移动应用系统、基于智能硬件的应用系统、Web应用系统。

具体要求：

（1）能使用所学C/Python等程序设计语言解决相对复杂的综合问题，目标集中，要有较为完整的主体业务逻辑（总体目标）；

（2）要采用合适的分层架构、视图和代码分离（总体架构）；

（3）要考虑系统所需要的用户界面适配显示效果（前端用户接口UI）；

（4）要使用MySQL/SQLServer/Oracle等数据库持久化的功能，其中移动应用系统、Web应用系统 !!!!重点:至少应包含6张业务逻辑关联数据表!!!!，并涉及到存储过程、触发器等技术点的应用（后端存储）；系统页面须实现响应式设计；整个系统须由前端页面和后台管理系统组成，后台管理系统能区分不同角色入口及对应管理权限；

（5）系统应该设计测试用例，通过测试，能反馈系统的稳定性和健壮性（系统测试），说明软/硬件系统核心功能是否达到预期；

（6）以微控制器（单片机51/STM32，推荐型号STM32L431RCT6，不建议使用型号STM32F103C8T6）为核心的智能应用系统，能够采用微控制器编写程序，实现传感器数据采集、设备终端数据显示、存储，系统应!!!!重点:具有联网功能!!!!、数据通讯、网络控制、数据处理等功能，设备终端硬件需个人独立设计（底板可用面包板设计或PCB设计；各功能模块在底板集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型，设计应贴合具体应用场景，避免同质化套壳设计；

（7）以微处理器（ARM）为核心的智能应用系统，采用ARM处理器编写程序，实现传感器数据采集、设备终端数据显示及存储，系统具有!!!!重点:联网功能!!!!、数据通讯、网络控制、数据处理等功能，设备终端硬件需个人独立设计（底板可用面包板设计或PCB设计；各功能模块在底板上集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型；

（8）智能物联网应用系统，针对特定的应用场景，采用物联网技术，将传感器、控制器、智能设备、互联网等多种物联网组件进行有机结合，实现对各种物品、设备、场所、人员的智能化管理和监控，要求选用合理的物联网中间件技术、系统运行安全稳定可靠，要求设备端硬件需个人独立设计（底板可用面包板设计，或PCB设计；各功能模块在底板上集成基础上开发并实现对应功能），系统设计时应体现不同方案的对比以及如何完成各器件的选型。

(9) !!!!重点:三端互通(移动端,云端,硬件端)!!!!

适用专业：计算机科学与技术（1-7）、智能科学与技术（1-8）、物联网工程（1-8）、信息管理与信息系统（1-5）
知网地址:https://co2.cnki.net/Login.html?dp=tfswufe&r=1685087871577
账户为学号例如:42212346
密码例如:let*********3(星号为加密部分)
```

## 项目核心背景信息 (Project Core Context)

为了方便AI/LLM在后续对话中快速理解上下文，以下是截至当前时间点的项目核心背景信息摘要。
HARDWARE.md是我已有的硬件的列表,如果需要另外的硬件我额外网购(全部是刚来物联网专业时开学前一股脑花300元买的(除了树莓派和NUCLEO),只不过大部分我都不会用,我的嵌入式硬件功底很差所以毕业项目硬件部分应该以简单为主,如果有更简单的请推荐我买更简单):

- **项目名称:** 基于边缘计算的藏红花全生长周期智能培育系统设计与实现
- **项目目标:** 设计并实现一个集数据采集、边缘处理、云端通信和跨平台应用控制于一体的完整物联网（IoT）智能农业解决方案。
- **核心架构 (四层模型):**
  1.  **感知控制层:** STM32微控制器负责实时采集环境数据（温湿度、光照、土壤湿度）并精确执行控制指令（水泵、补光灯等）。
  2.  **边缘计算层:** 树莓派作为边缘网关，负责与STM32进行串口通信，对数据进行本地存储、预处理和实时分析，并通过Flask提供局域网API服务。
  3.  **云服务层:** 采用MQTT协议，将边缘端处理后的关键数据上报至云端MQTT Broker，并订阅云端下发的控制指令，实现系统的远程监控。
  4.  **应用表现层:** 基于PWA（Progressive Web App）技术的前端应用，可自适应PC和移动设备，实现数据的可视化展现、远程设备控制和用户权限管理。

- **开发者及环境信息:**
  - **开发者操作系统:** **Arch Linux**
  - **嵌入式IDE:** **STM32CubeIDE**
  - **嵌入式调试工具:** **`minicom`** (串口通信测试)
  - **后端语言:** Python 3

- **硬件选型:**
  - **微控制器 (MCU):** `STM32L476RGT6U` (原型开发板: **NUCLEO-L476RG**)
  - **边缘计算设备:** **树莓派4B (Raspberry Pi 4B)**
  - **STM32 <-> 树莓派通信:** **UART串口**
  - **执行器与供电:** 5V 负载（泵/灯）+ 逻辑级 N-MOSFET 低边开关（继电器非必需；与树莓派分离供电但务必共地，电机端并联续流二极管）

---

## ✅ 项目规划清单 (Project Planning Checklist)

1.  **一句话项目描述:** `这个项目是做什么的？`
    > 答：一个集STM32数据采集、树莓派边缘处理、MQTT云通信和PWA跨平台控制于一体的藏红花智能培育物联网系统。
2.  **目标用户画像:** `我在为谁开发？`
    > 答：小王，一名对现代农业技术充满热情的智能农业专业学生或研究员。他希望通过自动化技术提高藏红花的种植效率和品质，并能随时随地通过手机或电脑（无论在本地还是外网）监控和管理培育环境。
3.  **MVP 功能列表:** `必须实现的核心功能有哪些？`
    > 1.  STM32能采集多路环境数据并上报给树莓派。
    > 2.  树莓派能接收数据、存入本地数据库，并通过API提供给前端。
    > 3.  PWA前端能实时展示来自API的环境数据。
    > 4.  用户能在PWA前端下发控制指令。
    > 5.  STM32能接收并执行树莓派转发来的控制指令。
    > 6.  树莓派能将数据推送到云端MQTT服务器。
4.  **技术栈清单:**
    > - **感知控制层 (STM32):** C语言, STM32 HAL库
    > - **边缘计算层 (树莓派):** Python, Flask, SQLAlchemy, Gunicorn, Paho-MQTT
    > - **云服务层:** 公共/自建 MQTT Broker (如 EMQX, Mosquitto)
    > - **应用表现层 (Web/PWA):** 原生 HTML/CSS/JavaScript（无框架），可选引入 ECharts（CDN）用于图表
    > - **可选（边缘视觉 AI）:** OpenCV (Python) 或简单阈值/形态学算法（无训练），若做轻量推理可用 Numpy 实现
    > - **数据库:** MySQL / MariaDB
    > - **开发/部署环境:** Arch Linux (开发), Raspberry Pi OS (部署), Nginx（静态资源）
5.  **高层架构图:**
    > ```
    > [ 感知控制层 ]          [ 边缘计算层 ]             [ 云服务层 ]             [ 应用表现层 ]
    > +-------------+        +----------------------+   +--------------+         +--------------+
    > | STM32       | UART   | Raspberry Pi         |   | MQTT Broker  |         | PWA          |
    > | + 传感器   | <------> | + Python Serial      |   |              |         | (PC/Mobile)  |
    > | + 执行器   |        | + Flask API (Local)  |---| (Internet) |---------|              |
    > +-------------+        | + MariaDB            |   |              |         +--------------+
    >                        | + MQTT Client        |---/              |
    >                        +----------------------+
    > ```
6.  **核心数据模型/表结构:** `项目的数据骨架，满足6张表要求。`
    > 答：详见下文 **“核心数据模型 (数据库设计)”** 章节。
7.  **主要页面线框图:**
    > - **登录页:** 用户名、密码输入。
    > - **数据仪表盘 (Dashboard):** 实时数据显示卡片、设备状态、ECharts实时曲线图、快捷控制开关；（可选）自动灌溉策略开关与阈值设置，边缘视觉告警指示。
    > - **历史数据页:** 按日期/时间范围查询历史数据，并以图表和表格形式展示。
    > - **后台管理页 (Admin):** 用户管理、角色权限分配、设备管理。
8.  **任务列表/看板:**
    > 答：见下文的 **“敏捷开发冲刺计划”**，已分解为四周的冲刺任务。
9.  **一个优秀的 README.md 草稿:**
    > 答：本文档本身即为项目 README 的持续演进版本。

---

## 核心数据模型 (数据库设计)

为满足毕业设计要求，系统设计以下6张核心数据表，均采用MySQL/MariaDB存储。

1.  **用户表 (users)**
    - `id` (INT, PK, AI): 用户ID
    - `username` (VARCHAR, UNIQUE): 用户名
    - `password_hash` (VARCHAR): 加密后的密码
    - `email` (VARCHAR, UNIQUE): 电子邮箱
    - `created_at` (DATETIME): 创建时间

2.  **角色表 (roles)**
    - `id` (INT, PK, AI): 角色ID
    - `role_name` (VARCHAR, UNIQUE): 角色名称 (如 'admin', 'observer')

3.  **用户角色关联表 (user_roles)**
    - `user_id` (INT, FK -> users.id): 用户ID
    - `role_id` (INT, FK -> roles.id): 角色ID

4.  **设备表 (devices)**
    - `id` (INT, PK, AI): 设备ID
    - `device_name` (VARCHAR): 设备名称 (如 '一号培育箱')
    - `location` (VARCHAR): 物理位置
    - `status` (VARCHAR): 设备状态 ('online', 'offline')
    - `last_seen` (DATETIME): 最后在线时间

5.  **传感器数据表 (sensor_data)**
    - `id` (BIGINT, PK, AI): 数据记录ID
    - `device_id` (INT, FK -> devices.id): 所属设备ID
    - `timestamp` (DATETIME, INDEX): 采集时间戳
    - `temperature` (FLOAT): 温度 (°C)
    - `humidity` (FLOAT): 湿度 (%)
    - `light_intensity` (FLOAT): 光照强度 (lux)
    - `soil_moisture` (FLOAT): 土壤湿度 (%)

6.  **控制日志表 (control_logs)**
    - `id` (BIGINT, PK, AI): 日志ID
    - `user_id` (INT, FK -> users.id): 操作用户ID
    - `device_id` (INT, FK -> devices.id): 被控设备ID
    - `actuator` (VARCHAR): 被控执行器 (如 'water_pump', 'led_light')
    - `action` (VARCHAR): 执行动作 (如 'ON', 'OFF')
    - `timestamp` (DATETIME): 操作时间
    - `result` (VARCHAR): 执行结果 ('success', 'failed')

> 可选扩展表：若启用自动水泵策略与边缘视觉告警

7.  **灌溉策略表 (irrigation_policies)**
    - `id` (INT, PK, AI)
    - `device_id` (INT, FK -> devices.id)
    - `enabled` (BOOLEAN): 是否启用自动灌溉
    - `soil_threshold_min` (FLOAT): 土壤湿度下限阈值 (%)
    - `watering_seconds` (INT): 每次浇水时长（秒）
    - `created_at` (DATETIME)
    - `updated_at` (DATETIME)

8.  **视觉告警表 (vision_alerts)**
    - `id` (BIGINT, PK, AI)
    - `device_id` (INT, FK -> devices.id)
    - `timestamp` (DATETIME, INDEX)
    - `alert_type` (VARCHAR): 如 'pest', 'mold', 'growth_anomaly'
    - `confidence` (FLOAT): 告警置信度（0-1）
    - `snapshot_path` (VARCHAR): 截图或短视频路径（可选）

---

## 🚀 敏捷开发冲刺计划 (Agile Development Sprint Plan) - 精细化任务分解

鉴于项目周期，我们采用以**周**为单位的冲刺（Sprint）模式。每个任务都被分解为具体、可执行的子任务。

---

### 要求符合性映射（与“2026届功能实现要求”逐条对照）

- （1）编程语言与主体业务逻辑：已采用 C（STM32）与 Python（Flask）。端到端链路与控制闭环明确，主体业务逻辑覆盖数据采集、传输、展示与控制。
- （2）分层架构与视图分离：四层架构（感知/边缘/云/表现）已定义；后端 API 与前端模板、静态资源分离。
- （3）UI 适配显示：采用原生 HTML/CSS/JS，使用媒体查询与响应式布局适配移动/桌面端；可选在仪表盘增加自动灌溉策略开关与视觉告警提示组件。
- （4）数据库与不少于 6 表、存储过程/触发器：设计了 `users/roles/user_roles/devices/sensor_data/control_logs` 六表；后续补充存储过程与触发器并在第三周任务落实。
- （5）测试用例与稳定性：第四周计划系统测试与压力测试，覆盖正常/异常场景。
- （6）MCU 智能应用与联网：STM32 采集 DHT11 数据，串口与边缘服务器通信；预留执行器控制（MOSFET/LED/水泵，5V 方案）。
- （7）ARM 侧（边缘）联网与控制：树莓派运行 Flask 与 MQTT 客户端，实现数据上报与指令转发。
- （8）物联网系统集成：感知、控制、网络与应用端一体化，使用合适的中间件（MQTT）；可选引入边缘视觉与自动灌溉策略形成闭环。
- （9）三端互通：硬件端（STM32）、边缘/云端（Flask + MQTT）、应用端（Web/PWA）贯通。

### **第一周：核心链路贯通 (The "Tracer Bullet" Sprint)**

**🎯 本周目标：** 跑通一个最简化的 **传感器 -> STM32 -> 树莓派 -> 浏览器** 的端到端**局域网**数据流。这是项目的“龙骨”，验证技术栈的可行性。

- #### **任务 1.1: STM32 环境搭建与传感器读取**
  - [x] **环境搭建:** 在 Arch Linux 上安装 STM32CubeIDE。
  - [x] **项目创建:** 在 CubeIDE 中为 NUCLEO-L476RG 创建新项目。
  - [x] **CubeMX 配置 (时钟与调试):** 配置 RCC (使用 HSI/HSE) 和 SYS (启用 SWD 调试)。
  - [x] **CubeMX 配置 (UART):** 启用一个 USART 实例 (如 USART2)，配置引脚、波特率 (e.g., 115200)。
  - [x] **CubeMX 配置 (传感器):** 为 DHT11 温湿度传感器配置一个 GPIO 引脚为输入/输出模式。
  - [x] **代码生成:** 从 CubeMX 生成初始化代码。
  - [x] **驱动编写:** 编写或移植 DHT11 驱动代码，实现读取温湿度值的函数。
  - [x] **主循环逻辑:** 在 `main.c` 的 `while(1)` 循环中，定时调用传感器读取函数。
  - [x] **[验证] 调试器验证:** 使用调试器 (Debugger) 设置断点，查看变量值，确认能读到非零的温湿度数据。

- #### **任务 1.2: STM32 数据格式化与串口发送**
  - [x] **JSON 格式化:** 在主循环中，使用 `sprintf` 将读取到的温湿度值格式化为 JSON 字符串 (e.g., `{"temp":25.5,"humi":60.1}\r\n`)。 **注意：** 必须包含换行符 `\r\n` 作为消息结束符。
  - [x] **UART 发送:** 调用 `HAL_UART_Transmit()` 函数将格式化后的字符串通过串口发送出去。
  - [x] **添加延迟:** 在循环中加入 `HAL_Delay()` 确保发送频率不会过高 (e.g., 每 2-5 秒一次)。
  - [x] **[验证] Arch Linux 串口监听:** 使用 `minicom -D /dev/ttyACM0 -b 115200` (或类似命令) 确认能持续收到正确的 JSON 数据流。

- #### **任务 1.3: 树莓派 Python 串口接收**
  - [x] **环境准备 (树莓派):** 安装 Python3, pip, 及 `pyserial` 库 (`pip install pyserial`)。
  - [x] **编写独立脚本 (`serial_test.py`):** 编写一个简单的 Python 脚本，使用 `pyserial` 循环读取串口一行数据 (`readline()`)，并打印到控制台。
  - [x] **[验证] 数据解析:** 运行脚本，确认能正确接收并解析来自 STM32 的 JSON 字符串，无乱码或丢包。

- #### **任务 1.4: 最小化 Flask API 服务**
  - [x] **环境准备 (树莓派):** 安装 `flask` (`pip install flask`)。
  - [x] **创建 Flask 应用 (`app.py`):** 搭建一个最基础的 "Hello World" Flask 应用。
  - [x] **数据暂存设计:** 设计一个简单的全局变量 (e.g., a dictionary `latest_data = {}`) 来存储最新的传感器读数。
  - [x] **集成串口读取:** 将 `serial_test.py` 的逻辑封装成一个函数，并使用 `threading` 在 Flask 应用启动时在后台线程中运行此函数，持续更新 `latest_data`。
  - [x] **创建 API 端点:** 编写 `GET /api/v1/sensors/latest` 路由，它返回 `latest_data` 的 JSON 格式。
  - [x] **[验证] API 测试:** 在另一台电脑上使用 `curl http://<树莓派IP>:5000/api/v1/sensors/latest` 或浏览器访问，确认能获取 JSON 数据。

- #### **任务 1.5: 纯 JS 实时数据显示**
  - [x] **创建 `index.html`:** 编写一个包含基本 HTML 结构的静态文件，内含用于显示数据的 `<div>` 或 `<span>` 元素 (e.g., `<p>Temperature: <span id="temp">--</span></p>`)。
  - [x] **编写 JavaScript:** 在 `<script>` 标签内，使用 `setInterval` 和 `fetch` API，每隔几秒请求一次后端的 `/api/v1/sensors/latest` 接口。
  - [x] **数据绑定:** 在 `fetch` 的回调函数中，解析返回的 JSON，并使用 `document.getElementById().innerText` 将数据更新到 HTML 页面上。
  - [x] **页面访问:** 通过 Flask 访问首页 `http://<树莓派IP>:5000/`（后端渲染 `templates/index.html`）。
  - [x] **[验证] 端到端流程:** 在浏览器中打开 `http://<树莓派IP>:5000/`，确认能看到来自 STM32 的数据在页面上实时刷新。

---

### **第二周：MVP 功能完善 (The MVP Feature Sprint)**

**🎯 本周目标：** 在核心链路基础上，扩展所有传感器，实现反向控制，并引入数据库进行数据持久化；可选打通“自动水泵策略”的最简闭环。

- #### **任务 2.1: STM32 功能扩展与反向控制**
  - [x] **多传感器集成:** 编写光照强度、土壤湿度传感器的驱动代码，并将其数据加入到上报的 JSON 结构中。
  - [ ] **执行器控制:** 使用 CubeMX 配置一个 GPIO 为推挽输出模式，用于驱动 MOSFET 模块（LED/5V 水泵）。
  - [ ] **控制函数编写:** 编写 `pump_on()` 和 `pump_off()` 函数来控制 GPIO 的高低电平。
  - [ ] **串口接收中断:** 配置 UART 接收中断，将收到的字符存入一个缓冲区。
  - [ ] **命令解析:** 在主循环中检查接收缓冲区，解析收到的 JSON 命令 (e.g., `{"actuator": "pump", "action": "on"}`)，并调用相应的控制函数。
  - [ ] **自动灌溉（可选，最小可行）:** 在边缘端新增后台任务（线程/定时器），周期拉取最新土壤湿度与策略：若 `enabled=true` 且 `soil_moisture < soil_threshold_min`，自动发送 `pump_on` 指令并按 `watering_seconds` 后 `pump_off`；写入 `control_logs`。
  - [ ] **[验证] 串口调试助手:** 使用 PC 串口工具发送控制 JSON，观察 STM32 上的 MOSFET/LED 或 5V 水泵是否动作。

- #### **任务 2.2: 后端数据库集成**
  - [ ] **数据库安装:** 在树莓派上安装 MariaDB/MySQL，并创建一个专用数据库和用户。
  - [ ] **Python 库安装:** 安装 `SQLAlchemy` 和 `PyMySQL` (`pip install flask-sqlalchemy pymysql`)。
  - [ ] **模型定义:** 在 Flask 应用中，使用 SQLAlchemy 定义 `Device` 和 `SensorData` 模型，对应数据库表结构。
  - [ ] **数据库初始化:** 编写一个命令或首次运行时自动创建所有数据表。
  - [ ] **数据持久化:** 修改串口接收的后台线程，在解析数据后，创建一个 `SensorData` 对象并存入数据库会话 (`db.session.add()`, `db.session.commit()`)。
  - [ ] （可选）**灌溉策略表:** 创建/维护 `irrigation_policies` 表的基础 CRUD（开/关、阈值、时长）。
  - [ ] （可选）**视觉告警表:** 创建/维护 `vision_alerts` 表的写入与查询 API（若启用视觉）。
  - [ ] **[验证] 数据库查询:** 使用数据库客户端 (如 `mysql` 命令行) 查询 `sensor_data` 表，确认新数据被持续写入。

- #### **任务 2.3: 后端控制 API 与日志**
  - [ ] **创建 `control_logs` 模型:** 在 Flask 中定义 `ControlLog` 模型。
  - [ ] **创建控制 API:** 创建 `POST /api/v1/control` 端点，接收形如 `{"actuator": "pump", "action": "on"}` 的 JSON body。
  - [ ] **指令转发:** API 内部逻辑将接收到的 JSON 格式化为与 STM32 约定的字符串，并通过 `pyserial` 写入串口。
  - [ ] **日志记录:** 每次调用控制 API 时，创建一个 `ControlLog` 记录并存入数据库。
  - [ ] **[验证] Postman/curl 测试:** 使用 Postman 或 curl 工具向该 API 发送 POST 请求，确认 STM32 端有响应，并且 `control_logs` 表中有新记录。

- #### **任务 2.4: 前端原生仪表盘（无框架）**
  - [ ] **静态资源结构:** 在后端项目内新增 `static/css`, `static/js/modules` 与页面模板 `templates/dashboard.html`。
  - [ ] **API 服务封装:** 在 `static/js/modules/api.js` 使用 `fetch` 封装 `GET /api/v1/sensors/latest` 与 `POST /api/v1/control`。
  - [ ] **实时仪表盘:** 在 `dashboard.html` 中以原生 DOM 更新卡片数据；图表可选通过 CDN 引入 ECharts 或使用 `<canvas>` 自绘简单折线图。
  - [ ] **控制按钮:** 在页面上添加设备控制按钮（如 灯/水泵 开关），调用控制 API 下发 JSON 指令。
  - [ ] **基础样式与响应式:** 采用 Flex/Grid 与媒体查询实现移动端/桌面端适配。
  - [ ] **[验证] 端到端控制:** 在浏览器点击按钮，确认 STM32 端执行器响应动作。

---

### **第三周：云端通信与用户体验 (The Cloud & UX Sprint)**

**🎯 本周目标：** 引入用户认证系统、集成 MQTT 实现远程通信、完善数据可视化和响应式布局，使系统成为一个完整的应用；可选引入边缘视觉告警采集与上报。

- #### **任务 3.1: 后端用户认证 (RBAC)**
  - [ ] **数据库建表:** 使用 SQLAlchemy 定义 `User`, `Role`, `UserRole` 模型并生成数据表。
  - [ ] **库安装:** 安装 `Flask-Bcrypt` 用于密码加密，`Flask-JWT-Extended` 用于 Token 认证。
  - [ ] **创建注册/登录 API:** 实现 `POST /api/v1/auth/register` 和 `POST /api/v1/auth/login` 接口。登录成功返回 JWT。
  - [ ] **API 保护:** 使用 `@jwt_required()` 装饰器保护需要登录才能访问的 API (如控制 API)。
  - [ ] **角色权限:** 创建一个自定义装饰器 (e.g., `@admin_required`)，用于保护只有管理员能访问的 API。
  - [ ] **[验证] Postman 测试:** 测试注册、登录、携带 Token 访问受保护接口、无 Token 访问失败等场景。

- #### **任务 3.2: 后端与原生前端历史数据**
  - [ ] **创建历史 API:** 实现 `GET /api/v1/sensors/history`，支持 `start_time` 和 `end_time` 作为查询参数，从数据库分页查询数据。
  - [ ] **历史数据页面:** 新增 `templates/history.html`，包含日期范围选择器。
  - [ ] **数据可视化:** 通过 CDN 引入 ECharts 渲染折线图，或使用 `<canvas>` 原生绘制。
  - [ ] **[验证] 页面交互:** 在前端选择不同时间段，确认图表能正确刷新并展示对应的数据。

- #### **任务 3.3: MQTT 云端集成**
  - [ ] **选择 Broker:** 确定使用一个公共 MQTT Broker (如 EMQX Public MQTT Server) 进行开发。
  - [ ] **库安装:** 在树莓派上安装 `paho-mqtt` (`pip install paho-mqtt`)。
  - [ ] **MQTT 客户端封装:** 编写一个 `mqtt_client.py` 模块，处理连接、发布、订阅和回调逻辑。
  - [ ] **数据上报:** 在主程序的后台线程中，除了存数据库外，还将每条传感器数据 publish 到一个 Topic (e.g., `saffron/device1/data`)。
  - [ ] **指令下发:** 让 MQTT 客户端 subscribe 一个控制 Topic (e.g., `saffron/device1/control/set`)。在 `on_message` 回调中，解析收到的云端指令，并写入串口。
  - [ ] **[验证] MQTTX 测试:** 使用 MQTT 客户端工具 (如 MQTTX) 订阅数据 Topic，确认能收到树莓派发来的数据；再向控制 Topic 发布指令，确认 STM32 有响应。
  - [ ] **视觉告警上报（可选）:** 运行一个简易摄像头采集/图片处理脚本（OpenCV 或阈值法），对明显异常进行判别并通过 Topic（如 `saffron/device1/vision/alerts`）上报；同步写入 `vision_alerts`。

- #### **任务 3.4: 原生前端完善与 PWA**
  - [ ] **登录/登出:** 创建 `templates/login.html`，实现登录/登出，使用 `localStorage` 存储 JWT。
  - [ ] **访问控制:** 采用多页面（`login.html` / `dashboard.html` / `history.html` / `admin.html`）；在页面脚本中检测 JWT，未登录跳转登录页。
  - [ ] **后台管理页:** 新增 `templates/admin.html`，原生表格展示用户列表与角色信息（管理员权限）。
  - [ ] **策略与视觉（可选 UI）:** 在 `dashboard.html` 添加自动灌溉策略的开/关与阈值设置控件；添加视觉告警提示区域与最近告警列表。
  - [ ] **响应式设计:** 使用 CSS Flex/Grid + 媒体查询，适配移动端与桌面端。
  - [ ] **PWA 配置:** 增加 `manifest.json` 与 `service-worker.js`，缓存关键静态资源与接口降级策略。
  - [ ] **[验证] 多设备测试:** 在 PC/手机浏览器访问应用，检查登录、权限、离线缓存与安装体验。

- #### **任务 3.5: 数据库高级功能**
  - [ ] **设计存储过程:** 编写一个 SQL 存储过程，例如 `CleanOldSensorData(days_to_keep INT)`，用于定期删除指定天数之前的传感器数据。
  - [ ] **设计触发器:** 编写一个 SQL 触发器，例如当 `control_logs` 表中插入一条新记录时，自动更新 `devices` 表中对应设备的 `last_seen` 字段。
  - [ ] **[验证] 手动调用:** 在数据库客户端中手动调用存储过程和触发相关操作，检查数据是否按预期变化。

---

### **第四周：测试、部署与文档 (The Polish, Deploy & Document Sprint)**

**🎯 本周目标：** 确保系统稳定可靠，完成生产环境部署，并集中精力完成毕业设计文档的撰写。**原则上，本周不开发新功能。**

- #### **任务 4.1: 系统健壮性测试**
  - [ ] **编写测试用例:** 创建一个表格，列出核心功能的测试用例，包括正常场景和异常场景。
    - _示例1 (正常):_ 用户登录 -> 查看实时数据 -> 发送开灯指令 -> 确认灯亮 -> 登出。
    - _示例2 (异常):_ STM32 意外断电，前端应显示设备离线或数据不再更新。
    - _示例3 (异常):_ 树莓派断网，测试 MQTT 重连机制是否生效。
  - [ ] **执行测试:** 逐一执行测试用例，记录结果，对发现的 Bug 进行修复。
  - [ ] **压力测试 (可选):** 编写脚本快速向 API 发送请求，观察系统资源占用情况。

- #### **任务 4.2: 生产环境部署**
  - [ ] **安装部署软件:** 在树莓派上安装 `gunicorn` 和 `nginx`。
  - [ ] **配置 Gunicorn:** 使用 Gunicorn 启动 Flask 应用，取代开发用的 `flask run`。
  - [ ] **配置 Nginx:** 编写 Nginx 配置文件，设置反向代理，将 80 端口的请求转发给 Gunicorn 运行的端口。
  - [ ] **配置 systemd 服务:** 编写 `.service` 文件，将 Gunicorn 服务和 Python 串口监听脚本配置为开机自启动。
  - [ ] **前端部署:** 直接部署 `templates/*.html` 与 `static/*` 到 Nginx 的 Web 根目录（或通过 Flask 的静态文件服务），无需打包流程。
  - [ ] **[验证] 重启测试:** 重启树莓派，稍等片刻后，直接通过 IP 访问，确认系统自动恢复并正常工作。

- #### **任务 4.3: 硬件定型**
  - [ ] **电路整理:** 将面包板上的电路整理清晰，确保连接稳固。
  - [ ] **焊接 (可选):** 如果时间充裕且条件允许，将电路焊接到洞洞板或设计的 PCB 上，制作一个简单的外壳。
  - [ ] **[验证] 最终硬件测试:** 确认定型后的硬件系统工作稳定。

- #### **任务 4.4: 文档与答辩准备**
  - [ ] **图表绘制:** 使用 draw.io 或类似工具绘制系统架构图、数据流图、数据库 E-R 图、核心 UML 用例图等。
  - [ ] **论文撰写:** 集中精力完成毕业论文的系统设计、实现、测试等关键章节的撰写。
  - [ ] **PPT 制作:** 准备答辩用的 PPT，内容应包括项目背景、需求分析、系统设计、核心功能演示、总结与展望。
  - [ ] **演示脚本:** 编写一份详细的现场演示流程脚本，确保演示流畅。

- #### **任务 4.5: 代码与项目收尾**
  - [ ] **代码审查与注释:** 通读所有代码，添加必要的注释，清理无用代码。
  - [ ] **README 完善:** 更新最终的 `README.md`，包含项目截图、技术栈详情、部署指南等。
  - [ ] **代码归档:** 将所有代码（STM32、Python 后端、原生前端）和文档整理归档，并提交到 Git 仓库。

### 采购建议（基于你已有清单，聚焦最小可行闭环）

- 电源与基础
  - 5V 3A 树莓派专用电源（带开关的 USB‑C 线）
  - microSD 卡 32GB（Class10/U1）
  - 5V 2–3A 直流电源适配器（给泵/植物灯等用，和树莓派电源分离，共地）

- 执行器与驱动（5V 方案）
  - 5V 迷你潜水泵 或 5V 蠕动泵（演示更稳推荐“蠕动泵”，流量可控、无回流）
  - 3.3V 兼容的 MOSFET 驱动模块 2 个（逻辑电平 N‑MOSFET，替代继电器）
  - 续流二极管（1N5819/1N4007），并联在电机两端做保护
  - 5V USB 植物灯/5V LED 灯条（演示光照控制）

- 传感器（精度和耐用性补齐）
  - BH1750 光照传感器（I2C，3.3V）
  - 电容式土壤湿度传感器（3.3–5V，耐腐蚀）
  - 防水 DS18B20（测土壤/水温；补足 DHT11 的精度与耐用性）
  - （备选升级）SHT31‑D 或 BME280（温湿度更稳）

- 水路与机电辅材
  - 硅胶软管（内径 4–6 mm，按泵接口选）、三通/直通/接头、单向阀、滴头
  - 小型水箱（带盖防尘）
  - 端子台/接线帽、扎带、热缩管、防水电工胶带
  - 塑料整理盒/防水盒（分隔强/弱电与水路）

- 可选扩展（提升演示效果）
  - USB 摄像头（边缘视觉/MQTT 告警演示）
  - 5V 小风扇（空气流通控制）
  - USB 供电分配模块（5V 多口），执行器与树莓派分离供电但共地

### 演示物品/作物（按季节与速度选择）

- 首选（贴合课题）
  - 藏红花球茎（预算允许；非当季或预算有限可选红色系现成盆栽如观赏辣椒/长寿花/一串红，颜色接近、演示友好）
  - 花盆（带排水孔）+ 育苗盘 + 通用营养土/泥炭土 + 珍珠岩
- 替代快生长作物（1–2 周内可见变化）
  - 小麦草/绿豆/红豆（发芽快，自动浇水效果直观）
  - 罗勒/薄荷/小葱（耐活、对光照/水分响应明显）
- 水路演示替代物
  - 海绵/陶粒模拟“土壤”，更容易定量展示湿度变化

### 与你现有硬件的适配说明

- 你已有的“5V 继电器模块（低电平触发）”不一定能被 STM32 的 3.3V 稳定驱动，建议使用“3.3V 兼容 MOSFET 驱动模块”作为通用执行器驱动（泵/风扇/灯）。
- 你已有的“电阻式土壤湿度传感器”易腐蚀、读数漂移大；演示可先用，正式建议换“电容式”。
- DHT11 可继续打通链路，后续用 SHT31‑D/BME280 替换以提升精度与论文说服力。

### 最小成套清单（一天内能跑通的闭环）

- 5V 3A 树莓派电源、microSD 32GB
- 5V 2–3A 适配器、5V 蠕动泵/5V USB 潜水泵、硅胶管+单向阀+水箱
- MOSFET 驱动模块 x2、续流二极管
- BH1750、电容式土壤湿度、DS18B20
- 花盆+营养土（或育苗盘）+ 快速发芽的豆类/小麦草
- 如需，我可以按你本地电商平台给出具体商品链接与参数（接口口径、尺寸、电流冗余）及接线图。

### 关键点

- 采购补齐：5V 执行器链路（泵/灯）、3.3V 兼容驱动、精度更高的光照/土壤/温度传感器。
- 演示物品：藏红花（当季）或红色系现成盆栽/快速发芽作物；盆+土+水路耗材。
- 安全/可靠：强弱电与水路隔离，执行器与树莓派分离供电但共地，电机端并联续流保护。